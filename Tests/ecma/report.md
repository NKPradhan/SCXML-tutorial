# Qt SCXML EcmaScript passing tests results

| Test | Result | Description |
|---|---|---|
| [W3C/test144.scxml](W3C/test144.scxml) | Pass | test that events are inserted into the queue in the order in which they are raised. If foo occurs before bar, success, otherwise failure |
| [W3C/test145.scxml](W3C/test145.scxml) | Pass | self defined test, to test spontaneous transitions after event driven transitions |
| [W3C/test147.scxml](W3C/test147.scxml) | Pass | test that the first clause that evaluates to true - and only that clause - is executed. Only one event should be raised, and it should be bar |
| [W3C/test148.scxml](W3C/test148.scxml) | Pass | test that the else clause executes if [\<if\>](../../Doc/if_else_elseif.md#if) and [\<elseif\>](../../Doc/if_else_elseif.md#elseif) evaluate to false. Baz should be the only event generated by the [\<if\>](../../Doc/if_else_elseif.md#if). bat is raised to catch the case where the [\<else\>](../../Doc/if_else_elseif.md#else) clause fails and baz is not generated, i.e. it makes sure that the test doesn't hang. |
| [W3C/test149.scxml](W3C/test149.scxml) | Pass | test that neither if clause executes, so that bat is the only event raised. |
| [W3C/test150.scxml](W3C/test150.scxml) | Pass | test that foreach causes a new variable to be declared if 'item' doesn't already exist. Also test that it will use an existing var if it does exist. |
| [W3C/test151.scxml](W3C/test151.scxml) | Pass | test that foreach causes a new variable to be declared if 'item' doesn't already exist. Also test that it will use an existing var if it does exist. |
| [W3C/test152.scxml](W3C/test152.scxml) | Pass | test that an illegal array or item value causes `error.execution` and results in executable content not being executed. |
| [W3C/test153.scxml](W3C/test153.scxml) | Pass | test that foreach goes over the array in the right order. since the array contains 1 2 3, we compare the current value with the previous value, which is stored in var1. The current value should always be larger. If it ever isn't, set Var4 to 0, indicating failure |
| [W3C/test155.scxml](W3C/test155.scxml) | Pass | test that foreach executes the executable content once for each item in the list '(1,2,3)'. The executable content sums the items into var1 so it should be 6 at the end |
| [W3C/test156.scxml](W3C/test156.scxml) | Pass | test that an error causes the foreach to stop execution. The second piece of executable content should cause an error, so var1 should be incremented only once |
| [W3C/test158.scxml](W3C/test158.scxml) | Pass | test that executable content executes in document order. if event1 occurs then event2, succeed, otherwise fail |
| [W3C/test159.scxml](W3C/test159.scxml) | Pass | test that any error raised by an element of executable content causes all subsequent elements to be skipped. The send tag will raise an error so var1 should not be incremented. If it is fail, otherwise succeed |
| [W3C/test172.scxml](W3C/test172.scxml) | Pass | we test that eventexpr uses the current value of var1, not its initial value |
| [W3C/test173.scxml](W3C/test173.scxml) | Pass | we test that targetexpr uses the current value of var1, not its initial value (If it uses the initial value, it will generate an error. If it uses the current value, event1 will be raised |
| [W3C/test174.scxml](W3C/test174.scxml) | Pass | we test that typeexpr uses the current value of var1, not its initial value (If it uses the initial value, it will generate an error. If it uses the current value, event1 will be raised |
| **[W3C/test175.scxml](W3C/test175.scxml)** | **Fail** | **we test that delayexpr uses the current value of var1, not its initial value (If it uses the initial value, event2 will be generated first, before event1. If it uses the current value, event1 will be raised first. Succeed if event1 occurs before event2, otherwise fail** |
| [W3C/test176.scxml](W3C/test176.scxml) | Pass | we test that [\<param\>](../../Doc/param.md) uses the current value of var1, not its initial value. If the value of aParam in event1 is 2 so that var2 gets set to 2, success, otherwise failure |
| **[W3C/test178.scxml](W3C/test178.scxml)** | **Fail** | **we test that multiple key/value pairs are included, even when the keys are the same. This is a manual test. The tester must look at the log output and verify that both keys are there. (This test uses the SCXML Event I/O processor, which is the only one that all platforms must support. It does not specify the message format, so we cannot test `_event.raw` directly. Therefore we print it out for visual inspection.)** |
| [W3C/test179.scxml](W3C/test179.scxml) | Pass | we test that [\<content\>](../../Doc/content.md) can be used to populate body of a message |
| [W3C/test183.scxml](W3C/test183.scxml) | Pass | we test that [\<send\>](../../Doc/send.md) stores the value of the sendid in idlocation. If it does, var1 has a value and we pass. Otherwise we fail |
| [W3C/test185.scxml](W3C/test185.scxml) | Pass | we test that [\<send\>](../../Doc/send.md) respects the delay specification. If it does, event1 arrives before event2 and we pass. Otherwise we fail |
| [W3C/test186.scxml](W3C/test186.scxml) | Pass | we test that [\<send\>](../../Doc/send.md) evals its args when it is evaluated, not when the delay interval expires and the message is actually sent. If it does, aParam will have the value of 1 (even though var1 has been incremented in the interval.) If var2 ends up == 1, we pass. Otherwise we fail |
| [W3C/test187.scxml](W3C/test187.scxml) | Pass | we test that delayed [\<send\>](../../Doc/send.md) is not sent if the sending session terminates. In this case, a subscript is invoked which sends the event childToParent delayed by 1 second, and then terminates. The parent session, should not receive childToParent. If it does, we fail. Otherwise the 10 sec timer expires and we pass |
| **[W3C/test189.scxml](W3C/test189.scxml)** | **Fail** | **we test that `#_internal` as a target of [\<send\>](../../Doc/send.md) puts the event on the internal queue. If it does, event1 will be processed before event2, because event1 is added to the internal queue while event2 is added to the external queue (event though event2 is generated first)** |
| **[W3C/test190.scxml](W3C/test190.scxml)** | **Fail** | **we test that `#_scxml_sessionid` as a target of [\<send\>](../../Doc/send.md) puts the event on the external queue. If it does, event1 will be processed before event2, because event1 is added to the internal queue while event2 is added to the external queue (event though event2 is generated first). we have to make sure that event2 is actually delivered. The delayed [\<send\>](../../Doc/send.md) makes sure another event is generated (so the test doesn't hang)** |
| [W3C/test191.scxml](W3C/test191.scxml) | Pass | we test that `#_parent` works as a target of [\<send\>](../../Doc/send.md) . a subscript is invoked and sends the event childToParent to its parent session (ths session) using `#_parent` as the target. If we get this event, we pass, otherwise we fail. The timer insures that some event is generated and that the test does not hang. |
| [W3C/test192.scxml](W3C/test192.scxml) | Pass | we test that `#_invokeid` works as a target of [\<send\>](../../Doc/send.md) . A child script is invoked and sends us childToParent once its running. Then we send it the event parentToChild using its invokeid as the target. If it receives this event, it sends sends the event eventReceived to its parent session (ths session). If we get this event, we pass, otherwise the child script eventually times out sends invoke.done and we fail. We also set a timeout in this process to make sure the test doesn't hang |
| [W3C/test193.scxml](W3C/test193.scxml) | Pass | we test that omitting target and targetexpr of [\<send\>](../../Doc/send.md) when using the SCXML event i/o processor puts the event on the external queue. |
| [W3C/test194.scxml](W3C/test194.scxml) | Pass | we test that specifying an illegal target for [\<send\>](../../Doc/send.md) causes the event `error.execution` to be raised. If it does, we succeed. Otherwise we eventually timeout and fail. |
| [W3C/test198.scxml](W3C/test198.scxml) | Pass | we test that if type is not provided [\<send\>](../../Doc/send.md) uses the scxml event i/o processor. The only way to tell what processor was used is to look at the origintype of the resulting event |
| [W3C/test199.scxml](W3C/test199.scxml) | Pass | we test that using an invalid send type results in `error.execution` |
| [W3C/test200.scxml](W3C/test200.scxml) | Pass | we test that the processor supports the scxml event i/o processor |
| **[W3C/test201.scxml](W3C/test201.scxml)** | **Fail** | **we test that the processor supports the basic http event i/o processor. This is an optional test since platforms are not required to support basic http event i/o** |
| [W3C/test205.scxml](W3C/test205.scxml) | Pass | we test that the processor doesn't change the message. We can't test that it never does this, but at least we can check that the event name and included data are the same as we sent. |
| **[W3C/test207.scxml](W3C/test207.scxml)** | **Timeout** | **we test that that we can't cancel an event in another session. We invoke a child process. It notifies us when it has generated a delayed event with sendid foo. We try to cancel foo. The child process sends us event event success if the event is not cancelled, event fail otherwise. This doesn't test that there is absolutely no way to cancel an event raised in another session, but the spec doesn't define any way to refer to an event in another process** |
| **[W3C/test208.scxml](W3C/test208.scxml)** | **Fail** | **we test that cancel works. We cancel delayed event1. If cancel works, we get event2 first and pass. If we get event1 or an error first, cancel didn't work and we fail.** |
| **[W3C/test210.scxml](W3C/test210.scxml)** | **Fail** | **we test that sendidexpr works with cancel. If it takes the most recent value of var1, it should cancel delayed event1. Thus we get event2 first and pass. If we get event1 or an error first, cancel didn't work and we fail.** |
| [W3C/test215.scxml](W3C/test215.scxml) | Pass | we test that typexpr is evaluated at runtime. If the original value of var1 is used, the invocation will fail (test215sub1.scxml is not of type 'foo', even if the platform supports foo as a type). If the runtime value is used, the invocation will succeed |
| **[W3C/test216.scxml](W3C/test216.scxml)** | **Timeout** | **we test that srcexpr is evaluated at runtime. If the original value of var1 is used, the invocation will fail (assuming that there is no script named 'foo'). If the runtime value is used, the invocation will succeed** |
| [W3C/test220.scxml](W3C/test220.scxml) | Pass | we test that the scxml type is supported. |
| [W3C/test223.scxml](W3C/test223.scxml) | Pass | we test that idlocation is supported. |
| [W3C/test224.scxml](W3C/test224.scxml) | Pass | we test that the automatically generated id has the form stateid.platformid. |
| [W3C/test225.scxml](W3C/test225.scxml) | Pass | we test that the automatically generated id is unique, we call invoke twice and compare the ids. |
| [W3C/test226.scxml](W3C/test226.scxml) | Pass | this is basically just a test that invoke works correctly and that you can pass data to the invoked process. If the invoked session finds aParam==1, it exits, signalling success. otherwise it will hang and the timeout in this doc signifies failure. |
| [W3C/test228.scxml](W3C/test228.scxml) | Pass | test that the invokeid is included in events returned from the invoked process. |
| [W3C/test229.scxml](W3C/test229.scxml) | Pass | test that autofoward works. If the child process receives back a copy of the childToParent event that it sends to this doc, it sends eventReceived, signalling success. (Note that this doc is not required to process that event explicitly. It should be forwarded in any case.) Otherwise it eventually times out and the `done.invoke` signals failure |
| [W3C/test230.scxml](W3C/test230.scxml) | Manual | a manual test that an autofowarded event has the same fields and values as the original event. the child process sends the parent process an event which is forwarded back to it. Both the parent and child process print out the contents of the event. The tester must check if they are the same and report his result. |
| [W3C/test232.scxml](W3C/test232.scxml) | Pass | test that a parent process can receive multiple events from a child process |
| [W3C/test233.scxml](W3C/test233.scxml) | Pass | test that finalize markup runs before the event is processed. The invoked process will return 2 in `_event.data.aParam,` so that new value should be in force when we select the transtitions. |
| [W3C/test234.scxml](W3C/test234.scxml) | Pass | test that only finalize markup in the invoking state runs. the first invoked process will return 2 in `_event.data.aParam,` while second invoked process sleeps without returning any events. Only the first finalize should execute. So when we get to s1 var1 should have value 2 but var2 should still be set to 1 |
| [W3C/test235.scxml](W3C/test235.scxml) | Pass | test that `done.invoke.id` event has the right id. the invoked child terminates immediately and should generate `done.invoke.foo` |
| [W3C/test236.scxml](W3C/test236.scxml) | Pass | test that `done.invoke.id` event is the last event we receive. the invoked process sends childToParent in the exit handler of its final state. We should get it before the `done.invoke,` and we should get no events after the `done.invoke.` Hence timeout indicates success |
| **[W3C/test237.scxml](W3C/test237.scxml)** | **Timeout** | **test that cancelling works. invoked child sleeps for two seconds, then terminates. We sleep for 1 sec in s0, then move to s1. This should cause the invocation to get cancelled. If we receive `done.invoke,` the invocation wasn't cancelled, and we fail. If we receive no events by the time timeout2 fires, success** |
| [W3C/test239.scxml](W3C/test239.scxml) | Pass | test that markup can be specified both by 'src' and by [\<content\>](../../Doc/content.md) |
| [W3C/test240.scxml](W3C/test240.scxml) | Pass | test that datamodel values can be specified both by 'namelist' and by [\<param\>](../../Doc/param.md). invoked child will return success if its Var1 is set to 1, failure otherwise. This test will fail schema validation because of the multiple occurences of Var1, but should run correctly. |
| [W3C/test241.scxml](W3C/test241.scxml) | Pass | The child process will return success ifits Var1 is set to 1, failure otherwise. For this test we try passing in Var1 by param and by namelist and check that we either get two successes or two failures. This test will fail schema validation due to multiple declarations of Var1, but should run correctly. |
| [W3C/test242.scxml](W3C/test242.scxml) | Pass | test that markup specified by 'src' and by [\<content\>](../../Doc/content.md) is treated the same way. That means that either we get `done.invoke` in both cases or in neither case (in which case we timeout) |
| [W3C/test243.scxml](W3C/test243.scxml) | Pass | test that datamodel values can be specified by param. test240sub1 will return success ifits Var1 is set to 1, failure otherwise. |
| [W3C/test244.scxml](W3C/test244.scxml) | Pass | test that datamodel values can be specified by namelist. invoked child will return success ifits Var1 is set to 1, failure otherwise. This test will fail schema validation due to multiple occurrences of Var1, but should run correctly. |
| [W3C/test245.scxml](W3C/test245.scxml) | Pass | test that non-existent datamodel values are not set. Var2 is not defined in invoked child's datamodel. It will will return success if its Var2 remains unbound, failure otherwise. |
| [W3C/test247.scxml](W3C/test247.scxml) | Pass | test that we get `done.invoke.` timeout indicates failure |
| [W3C/test250.scxml](W3C/test250.scxml) | Manual | test that the onexit handlers run in the invoked process if it is cancelled. This has to be a manual test, since this process won't accept any events from the child process once it has been cancelled. Tester must examine log output from child process to determine success |
| [W3C/test252.scxml](W3C/test252.scxml) | Pass | test that we don't process any events received from the invoked process once it is cancelled. child process tries to send us childToParent in an onexit handler. If we get it, we fail. timeout indicates success. |
| [W3C/test253.scxml](W3C/test253.scxml) | Pass | test that the scxml event processor is used in both directions. If child process uses the scxml event i/o processor to communicate with us, send it an event. It will send back success if this process uses the scxml processor to send the message to it, otherwise failure. For this test we allow 'scxml' as an alternative to the full url. |
| [W3C/test276.scxml](W3C/test276.scxml) | Pass | test that values passed in from parent process override default values specified in the child, test276sub1.scxml. The child returns event1 if var1 has value 1, event0 if it has default value 0. |
| [W3C/test277.scxml](W3C/test277.scxml) | Pass | test that platform creates undound variable if we assign an illegal value to it. Thus we can assign to it later in state s1. |
| [W3C/test278.scxml](W3C/test278.scxml) | Pass |  |
| [W3C/test279.scxml](W3C/test279.scxml) | Pass | testing that in case of early binding variables are assigned values at init time, before the state containing them is visited |
| [W3C/test280.scxml](W3C/test280.scxml) | Pass | test late binding. var2 won't get bound until s1 is entered, so it shouldn't have a value in s0 and accessing it should cause an error. It should get bound before the onentry code in s1 so it should be possible access it there and assign its value to var1 |
| [W3C/test286.scxml](W3C/test286.scxml) | Pass | test that assigment to a non-declared var causes an error. the transition on foo catches the case where no error is raised |
| [W3C/test287.scxml](W3C/test287.scxml) | Pass | a simple test that a legal value may be assigned to a valid data model location |
| **[W3C/test288.scxml](W3C/test288.scxml)** | **Fail** | **a simple test that a legal value may be assigned to a valid data model location using child content** |
| [W3C/test294.scxml](W3C/test294.scxml) | Pass | test that a param inside donedata ends up in the data field of the done event and that content inside donedata sets the full value of the event.data field |
| [W3C/test298.scxml](W3C/test298.scxml) | Pass | reference a non-existent data model location in param in donedata and see that the right error is raised |
| [W3C/test301.scxml](W3C/test301.scxml) | Manual | the processor should reject this document because it can't download the script. Therefore we fail if it runs at all. This test is valid only for datamodels that support scripting |
| [W3C/test302.scxml](W3C/test302.scxml) | Pass | test that a script is evaluated at load time. \<conf:script\> shoudl assign the value 1 to Var1. Hence, if script is evaluated at download time, Var1 has a value in the initial state s0. This test is valid only for datamodels that support scripting |
| [W3C/test303.scxml](W3C/test303.scxml) | Pass | to test that scripts are run as part of executable content, we check that it changes the value of a var at the right point. This test is valid only for datamodels that support scripting |
| [W3C/test304.scxml](W3C/test304.scxml) | Pass | test that a variable declared by a script can be accessed like any other part of the data model |
| [W3C/test307.scxml](W3C/test307.scxml) | Manual |  |
| [W3C/test309.scxml](W3C/test309.scxml) | Pass | test that an expression that cannot be interpreted as a boolean is treated as false |
| [W3C/test310.scxml](W3C/test310.scxml) | Pass | simple test of the `in()` predicate |
| [W3C/test311.scxml](W3C/test311.scxml) | Pass | test that assignment to a non-existent location yields an error |
| [W3C/test312.scxml](W3C/test312.scxml) | Pass | test that assignment with an illegal expr raises an error |
| [W3C/test313.scxml](W3C/test313.scxml) | Pass | this is a manual test. The processor is allowed to reject this doc, but if it executes it with its illegal expression, it must raise an error |
| [W3C/test314.scxml](W3C/test314.scxml) | Pass | this is a manual test because the processor is allowed to reject this document. But if it executes it, it should not raise an error until it gets to s03 and evaluates the illegal expr |
| [W3C/test318.scxml](W3C/test318.scxml) | Pass | test that `_event` stays bound during the onexit and entry into the next state |
| [W3C/test319.scxml](W3C/test319.scxml) | Pass | test that `_event` is not bound before any event has been raised |
| [W3C/test321.scxml](W3C/test321.scxml) | Pass | test that `_sessionid` is bound on startup |
| [W3C/test322.scxml](W3C/test322.scxml) | Pass | test that `_sessionid` remains bound to the same value throught the session. this means that it can't be assigned to |
| [W3C/test323.scxml](W3C/test323.scxml) | Pass | test that `_name` is bound on startup |
| [W3C/test324.scxml](W3C/test324.scxml) | Pass | test that `_name` stays bound till the session ends. This means that it cannot be assigned to |
| [W3C/test325.scxml](W3C/test325.scxml) | Pass | test that `_ioprocessors` is bound at startup. I'm not sure how to test for a set value or how to test that the entries in it do represent I/O processors, since the set that each implementation supports may be different. Suggestions welcome |
| [W3C/test326.scxml](W3C/test326.scxml) | Pass | test that `_ioprocessors` stays bound till the session ends. This means that it cannot be assigned to |
| [W3C/test329.scxml](W3C/test329.scxml) | Pass | test that none of the system variables can be modified |
| **[W3C/test330.scxml](W3C/test330.scxml)** | **Fail** | **check that the required fields are present in both internal and external events** |
| [W3C/test331.scxml](W3C/test331.scxml) | Pass |  |
| [W3C/test332.scxml](W3C/test332.scxml) | Pass | test that sendid is present in error events triggered by send errors |
| [W3C/test333.scxml](W3C/test333.scxml) | Pass | make sure sendid is blank in a non-error event |
| [W3C/test335.scxml](W3C/test335.scxml) | Pass | test that origin field is blank for internal events |
| [W3C/test336.scxml](W3C/test336.scxml) | Pass | test that the origin field of an external event contains a URL that lets you send back to the originator. In this case it's the same session, so if we get bar we succeed |
| [W3C/test337.scxml](W3C/test337.scxml) | Pass | test that origintype is blank on internal events |
| [W3C/test338.scxml](W3C/test338.scxml) | Pass | test that invokeid is set correctly in events received from an invoked process. timeout event catches the case where the invoke doesn't work correctly |
| [W3C/test339.scxml](W3C/test339.scxml) | Pass | test that invokeid is blank in an event that wasn't returned from an invoked process |
| [W3C/test342.scxml](W3C/test342.scxml) | Pass | test that eventexpr works and sets the name field of the resulting event |
| **[W3C/test343.scxml](W3C/test343.scxml)** | **Fail** | **test that illegal [\<param\>](../../Doc/param.md) produces `error.execution` and empty event.data** |
| [W3C/test344.scxml](W3C/test344.scxml) | Pass | test that a cond expression that cannot be evaluated as a boolean cond expression evaluates to false and causes `error.execution` to be raised. In some languages, any valid expression/object can be converted to a boolean, so conf:nonBoolean will have to be mapped onto something that produces a syntax error or something similarly invalid |
| [W3C/test346.scxml](W3C/test346.scxml) | Pass | test that any attempt to change the value of a system variable causes `error.execution` to be raised. Event1..4 are there to catch the case where the error event is not raised. In cases where it is, we have to dispose of eventn in the next state, hence the targetless transitions (which simply throw away the event.) |
| [W3C/test347.scxml](W3C/test347.scxml) | Pass | test that the scxml event I/O processor works by sending events back and forth between an invoked child and its parent process |
| [W3C/test348.scxml](W3C/test348.scxml) | Pass |  |
| [W3C/test349.scxml](W3C/test349.scxml) | Pass | test that value in origin field can be used to send an event back to the sender |
| **[W3C/test350.scxml](W3C/test350.scxml)** | **Fail** | **test that target value is used to decide what session to deliver the event to. A session should be able to send an event to itself using its own session ID as the target** |
| [W3C/test351.scxml](W3C/test351.scxml) | Pass | test that sendid is set in event if present in send, blank otherwise |
| [W3C/test352.scxml](W3C/test352.scxml) | Pass | test the origintype is 'http://www.w3.org/TR/scxml/#SCXMLEventProcessor' |
| [W3C/test354.scxml](W3C/test354.scxml) | Pass | test that event.data can be populated using both namelist, param and [\<content\>](../../Doc/content.md) and that correct values are used |
| [W3C/test355.scxml](W3C/test355.scxml) | Pass | test that default initial state is first in document order. If we enter s0 first we succeed, if s1, failure. |
| [W3C/test364.scxml](W3C/test364.scxml) | Pass | test that default initial states are entered when a compound state is entered. First we test the 'initial' attribute, then the initial element, then default to the first child in document order. If we get to s01111 we succeed, if any other state, failure. |
| [W3C/test372.scxml](W3C/test372.scxml) | Pass | test that entering a final state generates `done.state.parentid` after executing the onentry elements. Var1 should be set to 2 (but not 3) by the time the event is raised |
| [W3C/test375.scxml](W3C/test375.scxml) | Pass | test that onentry handlers are executed in document order. event1 should be raised before event2 |
| [W3C/test376.scxml](W3C/test376.scxml) | Pass | test that each onentry handler is a separate block. The [\<send\>](../../Doc/send.md) of event1 will cause an error but the increment to var1 should happen anyways |
| [W3C/test377.scxml](W3C/test377.scxml) | Pass | test that onexit handlers are executed in document order. event1 should be raised before event2 |
| [W3C/test378.scxml](W3C/test378.scxml) | Pass | test that each onexithandler is a separate block. The [\<send\>](../../Doc/send.md) of event1 will cause an error but the increment to var1 should happen anyways |
| [W3C/test387.scxml](W3C/test387.scxml) | Pass | test that the default history state works correctly. From initial state s3 we take a transition to s0's default shallow history state. That should generate "enteringS011", which takes us to s4. In s4, we transition to s1's default deep history state. We should end up in s122, generating "enteringS122". Otherwise failure. |
| [W3C/test388.scxml](W3C/test388.scxml) | Pass | test that history states works correctly. The counter Var1 counts how many times we have entered s0. The initial state is s012. We then transition to s1, which transitions to s0's deep history state. entering.s012 should be raised, otherwise failure. Then we transition to s02, which transitions to s0's shallow history state. That should have value s01, and its initial state is s011, so we should get entering.s011, otherwise failure. |
| [W3C/test396.scxml](W3C/test396.scxml) | Pass | test that the value in `_event.name` matches the event name used to match against transitions |
| [W3C/test399.scxml](W3C/test399.scxml) | Pass | test that the event name matching works correctly, including prefix matching and the fact that the event attribute of transition may contain multiple event designators. |
| [W3C/test401.scxml](W3C/test401.scxml) | Pass | test that errors go in the internal event queue. We send ourselves an external event foo, then perform and operation that raises an error. Then check that the error event is processed first, even though it was raised second |
| [W3C/test402.scxml](W3C/test402.scxml) | Pass | the assertion that errors are 'like any other event' is pretty broad, but we can check that they are pulled off the internal queue in order, and that prefix matching works on them. |
| [W3C/test403a.scxml](W3C/test403a.scxml) | Pass | we test one part of 'optimal enablement' meaning that of all transitions that are enabled, we chose the ones in child states over parent states, and use document order to break ties. We have a parent state s0 with two children, s01 and s02. In s01, we test that a) if a transition in the child matches, we don't consider matches in the parent and b) that if two transitions match in any state, we take the first in document order. In s02 we test that we take a transition in the parent if there is no matching transition in the child. |
| [W3C/test403b.scxml](W3C/test403b.scxml) | Pass | we test that 'optimally enabled set' really is a set, specifically that if a transition is optimally enabled in two different states, it is taken only once. |
| [W3C/test403c.scxml](W3C/test403c.scxml) | Pass | we test 'optimally enabled set', specifically that preemption works correctly |
| [W3C/test404.scxml](W3C/test404.scxml) | Pass | test that states are exited in exit order (children before parents with reverse doc order used to break ties before the executable content in the transitions. event1, event2, event3, event4 should be raised in that order when s01p is exited |
| [W3C/test405.scxml](W3C/test405.scxml) | Pass | test that the executable content in the transitions is executed in document order after the states are exited. event1, event2, event3, event4 should be raised in that order when the state machine is entered |
| [W3C/test406.scxml](W3C/test406.scxml) | Pass | Test that states are entered in entry order (parents before children with document order used to break ties) after the executable content in the transition is executed. event1, event2, event3, event4 should be raised in that order when the transition in s01 is taken |
| [W3C/test407.scxml](W3C/test407.scxml) | Pass | a simple test that onexit handlers work. var1 should be incremented when we leave s0 |
| [W3C/test409.scxml](W3C/test409.scxml) | Pass | we test that states are removed from the active states list as they are exited. When s01's onexit handler fires, s011 should not be on the active state list, so in(S011) should be false, and event1 should not be raised. Therefore the timeout should fire to indicate success |
| [W3C/test411.scxml](W3C/test411.scxml) | Pass | we test that states are added to the active states list as they are entered and before onentry handlers are executed. When s0's onentry handler fires we should not be in s01. But when s01's onentry handler fires, we should be in s01. Therefore event1 should not fire, but event2 should. Either event1 or timeout also indicates failure |
| [W3C/test412.scxml](W3C/test412.scxml) | Pass | test that executable content in the [\<initial\>](../../Doc/Introduction.md#initial-state) transition executes after the onentry handler on the state and before the onentry handler of the child states. Event1, event2, and event3 should occur in that order. |
| [W3C/test413.scxml](W3C/test413.scxml) | Pass | test that the state machine is put into the configuration specified by the initial element, without regard to any other defaults. we should start off in s2p111 and s2p122. the atomic states we should not enter all have immediate transitions to failure in them |
| [W3C/test415.scxml](W3C/test415.scxml) | Manual | Test that the state machine halts when it enters a top-level final state. Since the initial state is a final state, this machine should halt immediately without processing "event1" which is raised in the final state's on-entry handler. This is a manual test since there is no platform-independent way to test that event1 is not processed |
| [W3C/test416.scxml](W3C/test416.scxml) | Pass | test that the `done.state.id` gets generated when we enter the final state of a compound state |
| [W3C/test417.scxml](W3C/test417.scxml) | Pass | test that we get the `done.state.id` event when all of a parallel elements children enter final states. |
| [W3C/test419.scxml](W3C/test419.scxml) | Pass | test that eventless transitions take precedence over event-driven ones |
| [W3C/test421.scxml](W3C/test421.scxml) | Pass | test that internal events take priority over external ones, and that the processor keeps pulling off internal events until it finds one that triggers a transition |
| [W3C/test422.scxml](W3C/test422.scxml) | Pass | Test that at the end of a macrostep, the processor executes all invokes in states that have been entered and not exited during the step. (The invokes are supposed to be executed in document order, but we can test that since each invocation is separate and they may take different amounts to time to start up.) In this case, there are three invoke statements, in states s1, s11 and s12. Each invoked process returns an event named after its parent state. The invokes in s1 and s12 should execute, but not the one in s11. So we should receive invokeS1, invokeS12, but not invokeS12. Furthermore, when the timeout fires, var1 should equal 2. |
| [W3C/test423.scxml](W3C/test423.scxml) | Pass | test that we keep pulling external events off the queue till we find one that matches a transition. |
| [W3C/test444.scxml](W3C/test444.scxml) | Pass | test that [\<data\>](../../Doc/datamodel.md#data) creates a new ecmascript variable. |
| [W3C/test445.scxml](W3C/test445.scxml) | Pass | test that ecmascript objects defined by [\<data\>](../../Doc/datamodel.md#data) have value undefined if [\<data\>](../../Doc/datamodel.md#data) does not assign a value |
| [W3C/test446.scxml](W3C/test446.scxml) | Pass | in the ECMA data model, test that if the child of [\<data\>](../../Doc/datamodel.md#data) is JSON, the processor assigns it as the value of the var |
| [W3C/test448.scxml](W3C/test448.scxml) | Pass | test that all ecmascript objects are placed in a single global scope |
| [W3C/test449.scxml](W3C/test449.scxml) | Pass | test that ecmascript objects are converted to booleans inside cond |
| [W3C/test451.scxml](W3C/test451.scxml) | Pass | simple test of the `in()` predicate |
| **[W3C/test452.scxml](W3C/test452.scxml)** | **Fail** | **test that we can assign to any location in the datamodel. In this case, we just test that we can assign to a substructure (not the top level variable). This may not be the most idiomatic way to write the test** |
| [W3C/test453.scxml](W3C/test453.scxml) | Pass | test that we can use any ecmascript expression as a value expression. In this case, we just test that we can assign a function to a variable and then call it. |
| [W3C/test456.scxml](W3C/test456.scxml) | Pass | we can't test that `_any_` ecmascript is valid inside [\<script\>](../../Doc/script.md), so we just run a simple one and check that it can update the data model. |
| [W3C/test457.scxml](W3C/test457.scxml) | Pass | test that an the legal iterable collections are arrays, namely objects that satisfy instanceof(Array) in ECMAScript. the legal values for the 'item' attribute on foreach are legal ECMAScript variable names.. |
| [W3C/test459.scxml](W3C/test459.scxml) | Pass | test that foreach goes over the array in the right order. since the array contains 1 2 3, we compare the current value with the previous value, which is stored in var1. The current value should always be larger. If it ever isn't, set Var4 to 0, indicating failure. Also check that the final value of the index is 2 (meaning that the initial value was 0, not 1) |
| [W3C/test460.scxml](W3C/test460.scxml) | Pass | test that [\<foreach\>](../../Doc/foreach.md) does a shallow copy, so that modifying the array does not change the iteration behavior. |
| [W3C/test487.scxml](W3C/test487.scxml) | Pass | test illegal assignment. `error.execution` should be raised. |
| **[W3C/test488.scxml](W3C/test488.scxml)** | **Fail** | **test that illegal expr in [\<param\>](../../Doc/param.md) produces `error.execution` and empty event.data** |
| **[W3C/test495.scxml](W3C/test495.scxml)** | **Fail** | **test that the scxml event i/o processor puts events in the correct queues.** |
| [W3C/test496.scxml](W3C/test496.scxml) | Pass |  |
| **[W3C/test500.scxml](W3C/test500.scxml)** | **Fail** | **test that location field is found inside entry for SCXML Event I/O processor** |
| **[W3C/test501.scxml](W3C/test501.scxml)** | **Fail** | **test that the location entry for the SCXML Event I/O processor can be used as the target for an event** |
| [W3C/test503.scxml](W3C/test503.scxml) | Pass | test that a targetless transition does not exit and reenter its source state |
| [W3C/test504.scxml](W3C/test504.scxml) | Pass | test that an external transition exits all states up the the LCCA |
| [W3C/test505.scxml](W3C/test505.scxml) | Pass | test that an internal transition does not exit its source state |
| [W3C/test506.scxml](W3C/test506.scxml) | Pass | test that an internal transition whose targets are not proper descendants of its source state behaves like an external transition |
| **[W3C/test509.scxml](W3C/test509.scxml)** | **Fail** | **test that Basic HTTP Event I/O processor uses POST method and that it can receive messages at the accessURI** |
| **[W3C/test510.scxml](W3C/test510.scxml)** | **Fail** | **test that Basic HTTP messages go into external queue.** |
| **[W3C/test518.scxml](W3C/test518.scxml)** | **Fail** | **test that that namelist values get encoded as POST parameters.** |
| **[W3C/test519.scxml](W3C/test519.scxml)** | **Fail** | **test that that [\<param\>](../../Doc/param.md) values get encoded as POST parameters. .** |
| **[W3C/test520.scxml](W3C/test520.scxml)** | **Fail** | **test that that [\<content\>](../../Doc/content.md) gets sent as the body of the message.** |
| [W3C/test521.scxml](W3C/test521.scxml) | Pass | we test that the processor raises `error.communication` if it cannot dispatch the event. (To create an undispatchable event, we choose a non-existent session as target). If it raises the error event, we succeed. Otherwise we eventually timeout and fail. |
| **[W3C/test522.scxml](W3C/test522.scxml)** | **Fail** | **test that location field the entry for Basic HTTP Event I/O processor can be used to send a message to the processor** |
| [W3C/test525.scxml](W3C/test525.scxml) | Pass | test that [\<foreach\>](../../Doc/foreach.md) does a shallow copy, so that modifying the array does not change the iteration behavior. |
| [W3C/test527.scxml](W3C/test527.scxml) | Pass | simple test that 'expr' works with [\<content\>](../../Doc/content.md) |
| **[W3C/test528.scxml](W3C/test528.scxml)** | **Fail** | **test that illegal 'expr' produces `error.execution` and empty event.data** |
| [W3C/test529.scxml](W3C/test529.scxml) | Pass | simple test that children workn with [\<content\>](../../Doc/content.md) |
| [W3C/test530.scxml](W3C/test530.scxml) | Manual | test that [\<content\>](../../Doc/content.md) child is evaluated when [\<invoke\>](../../Doc/invoke.md) is. Var1 is initialized with an integer value, then set to an scxml script in the onentry to s0. If [\<content\>](../../Doc/content.md) is evaluated at the right time, we should get invoke.done, otherwise an error |
| **[W3C/test531.scxml](W3C/test531.scxml)** | **Fail** | **test that that the value of the [\<param\>](../../Doc/param.md) `_scxmleventname` gets used as the name of the raised event.** |
| **[W3C/test532.scxml](W3C/test532.scxml)** | **Fail** | **test that that if `_scxmleventname` is not present, the name of the HTTP method is used as the name of the resulting event.** |
| [W3C/test533.scxml](W3C/test533.scxml) | Pass | test that an internal transition whose source state is not compound does exit its source state |
| **[W3C/test534.scxml](W3C/test534.scxml)** | **Fail** | **test that that [\<send\>](../../Doc/send.md) 'event' value gets sent as the param `_scxmleventname` .** |
| [W3C/test550.scxml](W3C/test550.scxml) | Pass | test that expr can be used to assign a value to a var. This test uses early binding |
| [W3C/test551.scxml](W3C/test551.scxml) | Pass | test that inline content can be used to assign a value to a var. |
| [W3C/test552.scxml](W3C/test552.scxml) | Pass | test that src content can be used to assign a value to a var. Edit test552.txt to have a value that's legal for the datamodel in question |
| **[W3C/test553.scxml](W3C/test553.scxml)** | **Fail** | **we test that the processor does not dispatch the event if evaluation of [\<send\>](../../Doc/send.md)'s args causes an `error..`** |
| [W3C/test554.scxml](W3C/test554.scxml) | Pass | test that if the evaluation of [\<invoke\>](../../Doc/invoke.md)'s args causes an error, the invocation is cancelled. In this test, that means that we don't get `done.invoke` before the timer goes off. |
| **[W3C/test557.scxml](W3C/test557.scxml)** | **Fail** | **in the ECMA data model, test that if the child of [\<data\>](../../Doc/datamodel.md#data) is XML, or if XML is loaded via src=, the processor assigns it as the value of the var** |
| **[W3C/test558.scxml](W3C/test558.scxml)** | **Fail** | **in the ECMA data model, test that if the child of [\<data\>](../../Doc/datamodel.md#data) is not XML, or if XML is loaded via src=, the processor treats the value as a string, does whitespace normalization and assigns it to the var.** |
| [W3C/test560.scxml](W3C/test560.scxml) | Pass | in the ECMA data model, test that processor creates correct structure in `_event.data` when receiving KVPs in an event |
| **[W3C/test561.scxml](W3C/test561.scxml)** | **Fail** | **in the ECMA data model, test that processor creates an ECMAScript DOM object `_event.data` when receiving XML in an event** |
| [W3C/test562.scxml](W3C/test562.scxml) | Manual | in the ECMA data model, test that processor creates space normalized string in `_event.data` when receiving anything other than KVPs or XML in an event |
| **[W3C/test567.scxml](W3C/test567.scxml)** | **Fail** | **test that that any content in the message other than `_scxmleventname` is used to populate `_event.data.`** |
| [W3C/test569.scxml](W3C/test569.scxml) | Pass | test that location field is found inside entry for SCXML Event I/O processor in the ECMAScript data model. The tests for the relevant event i/o processors will test that it can be used to send events. |
| [W3C/test570.scxml](W3C/test570.scxml) | Pass | test that we generate `done.state.id` when all a parallel state's children are in final states |
| [W3C/test576.scxml](W3C/test576.scxml) | Pass | test that the 'initial' value of scxml is respected. We set the value to deeply nested non-default parallel siblings and test that both are entered. |
| **[W3C/test577.scxml](W3C/test577.scxml)** | **Fail** | **test that that [\<send\>](../../Doc/send.md) without target in basichttp event i/o processor causes `error.communication` to get added to internal queue .** |
| [W3C/test578.scxml](W3C/test578.scxml) | Pass | in the ECMA data model, test that processor creates an ECMAScript object `_event.data` when receiving JSON in an event |
| [W3C/test579.scxml](W3C/test579.scxml) | Pass | test that default history content is executed correctly. The Process MUST execute any executable content in the transition after the parent state's onentry handlers, and, in the case where the history pseudo-state is the target of an [\<initial\>](../../Doc/Introduction.md#initial-state) transition, the executable content inside the [\<initial\>](../../Doc/Introduction.md#initial-state) transition. However the Processor MUST execute this content only if there is no stored history. Once the history state's parent state has been visited and exited, the default history content must not be executed |
| [W3C/test580.scxml](W3C/test580.scxml) | Pass | test that a history state never ends up part of the configuration |
